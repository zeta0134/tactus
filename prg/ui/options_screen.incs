; ======================================================================
;                         Layouts and Widgets
; ======================================================================

.macro widget_options_battlefield
    .addr options_battlefield_init
    .byte 0, 0, 0, 0, 0, 0, 0, 0
.endmacro

options_ui_layout:
        widget_controller options_controller_init
        widget_cursor
        widget_text_label game_options_str, 2, 13
        widget_text_options game_mode_str,      game_mode_types,      setting_game_mode,      4, 15
        widget_text_options disco_floor_str,    disco_types,          setting_disco_floor,    4, 16
        widget_text_label player_options_str, 2, 18
        widget_text_options player_palette_preset_str, player_palette_preset_types, setting_player_palette_preset, 4, 20
        widget_numeric_slider player_palette_outfit_str, 16, 38, setting_personal_color_index_pajamas, 4, 22
        widget_numeric_slider player_palette_shoes_str,  16, 51, setting_personal_color_index_phones,  4, 23
        widget_numeric_slider player_palette_face_str,   16, 38, setting_personal_color_index_pigment, 4, 24
        widget_text_button back_to_title_str, return_to_title, 9, 26
        widget_options_battlefield
        widget_controller apply_fancy_color_shenanigans
        .addr $0000 ; end of list

; Used for manual tweaking of the values
PRESET_FIELD_INDEX = 6
PRESET_PERSONALIZED_VALUE = 4

game_options_str:   .asciiz "GAMEPLAY OPTIONS"
game_mode_str:      .asciiz "Rhythm "
disco_floor_str:    .asciiz "Floor  "
player_options_str: .asciiz "PLAYER PALETTE"
player_palette_preset_str: .asciiz "Preset  "
player_palette_outfit_str: .asciiz "Pajamas "
player_palette_shoes_str:  .asciiz "Phones  "
player_palette_face_str:   .asciiz "Pigment "
back_to_title_str:  .asciiz "RETURN TO TITLE"

disco_types:
        .byte 6 ; length of option set
        .addr disco_option_0_str
        .addr disco_option_1_str
        .addr disco_option_2_str
        .addr disco_option_3_str
        .addr disco_option_4_str
        .addr disco_option_5_str

disco_option_0_str: .asciiz "INSTANT SQUARES"
disco_option_1_str: .asciiz "FROZEN SQUARES"
disco_option_2_str: .asciiz "INSTANT OUTLINES"
disco_option_3_str: .asciiz "FROZEN OUTLINES"
disco_option_4_str: .asciiz "JUST GROOVEMENT"
disco_option_5_str: .asciiz "NO MOTION"

player_palette_preset_types:
        .byte 5 ; selectable length of option set
        .addr player_palette_preset_option_0_str
        .addr player_palette_preset_option_1_str
        .addr player_palette_preset_option_2_str
        .addr player_palette_preset_option_3_str
        .addr player_palette_preset_option_custom_str

player_palette_preset_option_0_str:      .asciiz "PEONY"
player_palette_preset_option_1_str:      .asciiz "PERIWINKLE"
player_palette_preset_option_2_str:      .asciiz "PETUNIA"
player_palette_preset_option_3_str:      .asciiz "PROTEA"
player_palette_preset_option_custom_str: .asciiz "PERSONALIZED"

game_mode_types:
        .byte 3 ; length of option set
        .addr game_mode_standard_str
        .addr game_mode_patient_str
        .addr game_mode_doubletime_str

game_mode_standard_str:   .asciiz "STANDARD"
game_mode_patient_str:    .asciiz "PATIENT"
game_mode_doubletime_str: .asciiz "DOUBLETIME"

; ======================================================================
;                       Screen Specific Logic
; ======================================================================

options_battlefield_bg_palette:
        .incbin "../art/dank_cave.pal"
options_obj_palette:
        .incbin "../art/options_sprite_palette.pal"

.proc options_controller_init
CurrentWidgetIndex := R20
        ; Play the options track on the options screen
        lda #TRACK_OPTIONS
        ldy #TRACK_VARIANT_NORMAL
        jsr play_track

        ; the options screen DOES use extended attributes, so set that up
        lda #0
        sta LeftNametableBank
        sta RightNametableBank
        lda #(NT_FPGA_RAM | NT_EXT_BANK_2 | NT_EXT_BG_AT)
        sta LeftNametableAttr
        sta RightNametableAttr

        ; Get the option palettes loaded in
        ldy #0
bg_loop:
        perform_zpcm_inc
        lda options_battlefield_bg_palette, y
        sta BgPaletteBuffer, y
        lda options_obj_palette, y
        sta ObjPaletteBuffer, y
        iny
        cpy #16
        bne bg_loop


        ldy CurrentWidgetIndex
        set_widget_state_y options_controller_update
        rts
.endproc

.proc options_controller_update
        lda #KEY_B
        and ButtonsDown
        beq stay_here
        jsr return_to_title
        rts
stay_here:
        rts
.endproc

.proc return_to_title
        st16 R0, sfx_teleport
        jsr play_sfx_pulse1

        st16 FadeToGameMode, title_prep
        st16 GameMode, fade_to_game_mode
        rts
.endproc

OPTIONS_DISCO_STATE_APPEARING    := 0
OPTIONS_DISCO_STATE_ACTIVE       := 1
OPTIONS_DISCO_STATE_DISAPPEARING := 2

; Note: obviously clobbers the active battlefield. If we
; decide to make this screen available during gameplay, be
; sure to preserve the battlefield state. Generally there is
; no need to preserve anything else; the options battlefield
; is extremely lightweight and will manage the rest of its state.
; We just want the battlefield to apply disco logic for the most part.
.proc options_battlefield_init
MetaSpriteIndex := R0
CurrentWidgetIndex := R20
widget_last_beat := widgets_data0
widget_player_sprite_index := widgets_data1
widget_disco_state := widgets_data2
widget_disco_active_setting := widgets_data3

        ldx CurrentWidgetIndex
        lda #OPTIONS_DISCO_STATE_APPEARING
        sta widget_disco_state, x
        lda setting_disco_floor
        sta widget_disco_active_setting, x

        far_call FAR_find_unused_sprite
        lda MetaSpriteIndex
        ldy CurrentWidgetIndex
        sta widget_player_sprite_index, y

        ldx widget_player_sprite_index, y
        lda #(SPRITE_ACTIVE | SPRITE_PAL_0)
        sta sprite_table + MetaSpriteState::BehaviorFlags, x
        lda #$FF
        sta sprite_table + MetaSpriteState::LifetimeBeats, x
        lda #80
        sta sprite_table + MetaSpriteState::PositionX, x
        lda #64
        sta sprite_table + MetaSpriteState::PositionY, x
        lda #<SPRITE_TILE_PLAYER
        sta sprite_table + MetaSpriteState::TileIndex, x

        ldx CurrentWidgetIndex
        lda CurrentBeat
        sta widget_last_beat, x

        ldx #0
top_wall_loop:
        lda #TILE_WALL
        sta battlefield, x
        lda #<BG_TILE_MAP_TILES_0231 ; cave wall, lower midsection
        sta tile_patterns, x
        sta tile_detail, x
        lda #((>BG_TILE_MAP_TILES_0231) | PAL_YELLOW) ; cave wall, lower midsection
        sta tile_attributes, x
        lda #0
        sta tile_flags, x
        sta tile_data, x
        inx
        cpx #16
        bne top_wall_loop

bottom_wall_loop:
        lda #TILE_WALL
        sta battlefield, x
        lda #<BG_TILE_MAP_TILES_0247 ; cave wall, front midsection
        sta tile_patterns, x
        sta tile_detail, x
        lda #((>BG_TILE_MAP_TILES_0247) | PAL_RED) ; cave wall, lower midsection
        sta tile_attributes, x
        lda #0
        sta tile_flags, x
        sta tile_data, x
        inx
        cpx #32
        bne bottom_wall_loop

disco_floor_top:
        lda #TILE_DISCO_FLOOR
        sta battlefield, x
        lda #<BG_TILE_DISCO_FLOOR_TILES_0002 ; disco floor with upper dashed lines
        sta tile_patterns, x
        sta tile_detail, x
        lda #((>BG_TILE_DISCO_FLOOR_TILES_0002) | PAL_WORLD) ; cave wall, lower midsection
        sta tile_attributes, x
        lda #0
        sta tile_flags, x
        sta tile_data, x
        inx
        cpx #48
        bne disco_floor_top

disco_floor_mid:
        lda #TILE_DISCO_FLOOR
        sta battlefield, x
        lda #<BG_TILE_DISCO_FLOOR_TILES_0000 ; disco floor, plain
        sta tile_patterns, x
        sta tile_detail, x
        lda #((>BG_TILE_DISCO_FLOOR_TILES_0000) | PAL_WORLD) ; cave wall, lower midsection
        sta tile_attributes, x
        lda #0
        sta tile_flags, x
        sta tile_data, x
        inx
        cpx #80
        bne disco_floor_mid

disco_floor_bottom:
        lda #TILE_DISCO_FLOOR
        sta battlefield, x
        lda #<BG_TILE_DISCO_FLOOR_TILES_0018 ; disco floor with lower dashed lines
        sta tile_patterns, x
        sta tile_detail, x
        lda #((>BG_TILE_DISCO_FLOOR_TILES_0018) | PAL_WORLD) ; cave wall, lower midsection
        sta tile_attributes, x
        lda #0
        sta tile_flags, x
        sta tile_data, x
        inx
        cpx #96
        bne disco_floor_bottom

        ; draw some colored enemies so the battlefield isn't empty
        ; (and we can preview the color thing)
        ; these will still use WALL logic, so they don't actually update

        ldx #(3 * BATTLEFIELD_WIDTH + 2)
        lda #TILE_WALL
        sta battlefield, x
        lda #<BG_TILE_MUSHROOM_IDLE
        sta tile_patterns, x
        lda #(>BG_TILE_MUSHROOM_IDLE | PAL_RED)
        sta tile_attributes, x

        ldx #(2 * BATTLEFIELD_WIDTH + 7)
        lda #TILE_WALL
        sta battlefield, x
        lda #<BG_TILE_MUSHROOM_IDLE
        sta tile_patterns, x
        lda #(>BG_TILE_MUSHROOM_IDLE | PAL_BLUE)
        sta tile_attributes, x

        ldx #(4 * BATTLEFIELD_WIDTH + 9)
        lda #TILE_WALL
        sta battlefield, x
        lda #<BG_TILE_MUSHROOM_IDLE
        sta tile_patterns, x
        lda #(>BG_TILE_MUSHROOM_IDLE | PAL_YELLOW)
        sta tile_attributes, x

        ldx #(3 * BATTLEFIELD_WIDTH + 12)
        lda #TILE_WALL
        sta battlefield, x
        lda #<BG_TILE_MUSHROOM_IDLE
        sta tile_patterns, x
        lda #(>BG_TILE_MUSHROOM_IDLE | PAL_WORLD)
        sta tile_attributes, x

        ; finally draw in some bouncy floor mushrooms, to demonstrate the groovement setting
        ldx #(3 * BATTLEFIELD_WIDTH + 4)
        lda #<BG_TILE_DISCO_FLOOR_TILES_0006 ; plain mushroom
        sta tile_patterns, x
        sta tile_detail, x
        ldx #(3 * BATTLEFIELD_WIDTH + 11)
        lda #<BG_TILE_DISCO_FLOOR_TILES_0006 ; plain mushroom
        sta tile_patterns, x
        sta tile_detail, x
        ldx #(4 * BATTLEFIELD_WIDTH + 14)
        lda #<BG_TILE_DISCO_FLOOR_TILES_0006 ; plain mushroom
        sta tile_patterns, x
        sta tile_detail, x

        ldx #(3 * BATTLEFIELD_WIDTH + 8)
        lda #<BG_TILE_DISCO_FLOOR_TILES_0007 ; tall mushroom
        sta tile_patterns, x
        sta tile_detail, x
        ldx #(4 * BATTLEFIELD_WIDTH + 3)
        lda #<BG_TILE_DISCO_FLOOR_TILES_0007 ; tall mushroom
        sta tile_patterns, x
        sta tile_detail, x

        ldy CurrentWidgetIndex
        set_widget_state_y options_battlefield_draw

        rts
.endproc

; todo: if necessary, break this out into several states
; (but ideally we do it all in one go and skip the dual-nametable thing)
.proc options_battlefield_draw
CurrentWidgetIndex := R20
        ; we want to draw to the LEFT battlefield, so we set "active" to
        ; the RIGHT battlefield (we're cheating a bit here)
        lda #1
        sta active_battlefield

        far_call FAR_draw_battlefield_block_A_inline
        far_call FAR_draw_battlefield_block_B_inline
        far_call FAR_draw_battlefield_block_C_inline

        ldy CurrentWidgetIndex
        set_widget_state_y options_battlefield_update

        rts
.endproc

; TODO: if necessary, break this out into several states
.proc options_battlefield_update
StartingRow := R14
StartingTile := R15
CurrentWidgetIndex := R20

widget_last_beat := widgets_data0
widget_player_sprite_index := widgets_data1
widget_disco_state := widgets_data2
widget_disco_active_setting := widgets_data3

        ; check to see if we need to switch sub-states due to a setting change
        ldx CurrentWidgetIndex
        lda setting_disco_floor
        cmp widget_disco_active_setting, x
        beq no_change_needed
        ; if we are currently appearing, we are fine to proceed (this will update the setting)
        lda widget_disco_state, x
        cmp #OPTIONS_DISCO_STATE_APPEARING
        beq no_change_needed
        ; otherwise, flip to the "disappearing" state to force a transition
        lda #OPTIONS_DISCO_STATE_DISAPPEARING
        sta widget_disco_state, x
no_change_needed:

        ; now perform setup for this specific sub-state
        ldx CurrentWidgetIndex
        lda widget_disco_state, x
        cmp #OPTIONS_DISCO_STATE_ACTIVE
        beq disco_tiles_active_state
        cmp #OPTIONS_DISCO_STATE_DISAPPEARING
        beq disco_tiles_disappearing_state
disco_tiles_appearing_state:
        lda setting_disco_floor
        sta widget_disco_active_setting, x
        lda #0
        sta current_clear_status
        lda #1
        sta previous_clear_status
        lda #OPTIONS_DISCO_STATE_ACTIVE
        sta widget_disco_state, x
        jmp converge
disco_tiles_active_state:
        lda #0
        sta current_clear_status
        lda #0
        sta previous_clear_status
        jmp converge
disco_tiles_disappearing_state:
        lda #1
        sta current_clear_status
        lda #0
        sta previous_clear_status
        lda #OPTIONS_DISCO_STATE_APPEARING
        sta widget_disco_state, x
converge:
        
        ; now, preserve the real setting and temporarily load the state-specific one
        lda setting_disco_floor
        pha
        ldx CurrentWidgetIndex
        lda widget_disco_active_setting, x
        sta setting_disco_floor

        lda CurrentBeat
        sta CurrentBeatCounter

        lda #2
        sta StartingRow
        lda #(::BATTLEFIELD_WIDTH * 2)
        sta StartingTile
        far_call FAR_update_static_enemy_row

        lda #3
        sta StartingRow
        lda #(::BATTLEFIELD_WIDTH * 3)
        sta StartingTile
        far_call FAR_update_static_enemy_row

        lda #4
        sta StartingRow
        lda #(::BATTLEFIELD_WIDTH * 4)
        sta StartingTile
        far_call FAR_update_static_enemy_row

        lda #5
        sta StartingRow
        lda #(::BATTLEFIELD_WIDTH * 5)
        sta StartingTile
        far_call FAR_update_static_enemy_row

        ; un-clobber the disco setting that we preserved
        pla
        sta setting_disco_floor

        ; and we... should be set?

        ldy CurrentWidgetIndex
        set_widget_state_y options_battlefield_wait_for_beat

        rts
.endproc

.proc options_battlefield_wait_for_beat
CurrentWidgetIndex := R20
widget_last_beat := widgets_data0
        
        ; while waiting, we can update some other nonessential things
        far_call FAR_apply_player_palette
        lda #1
        sta ObjPaletteDirty

        ldx CurrentWidgetIndex
        lda CurrentBeat
        cmp widget_last_beat, x
        bne advance
        rts
advance:
        sta widget_last_beat, x

        ;set_widget_state_y options_battlefield_draw
        ; draw right now!
        jsr options_battlefield_draw

        rts
.endproc

.proc apply_fancy_color_shenanigans
        ; When left/right are pressed, if we are currently on the Preset
        ; field, apply the preset colors to the sliders. If we're currently
        ; on any of the other fields, apply the slider values to the preset instead.
        lda #(KEY_RIGHT | KEY_LEFT)
        bit ButtonsDown
        bne perform_shenanigans
        rts

perform_shenanigans:
        ldx #PRESET_FIELD_INDEX
        lda widgets_state_flags, x
        and #WIDGET_STATE_HOVER
        bne preset_is_hovered
preset_is_not_hovered:
        jsr sync_sliders_to_preset
        jsr update_player_color_values
        rts
preset_is_hovered:
        jsr sync_preset_to_sliders
        jsr update_player_color_values
        rts
.endproc

.proc sync_preset_to_sliders
        ; If the preset value is anything other than "Personalized", then
        ; read the preset and apply the colors to the sliders
        ldx setting_player_palette_preset
        cpx #PRESET_PERSONALIZED_VALUE
        beq change_nothing

        ldy palette_preset_lut_phones, x
        sty setting_personal_color_index_phones
        ldy palette_preset_lut_pajamas, x
        sty setting_personal_color_index_pajamas
        ldy palette_preset_lut_pigment, x
        sty setting_personal_color_index_pigment

change_nothing:
        rts
.endproc

.proc sync_sliders_to_preset
        ; If the sliders don't currently equal the preset value, switch
        ; the preset value to "Personalized"
        ldx setting_player_palette_preset
        cpx #PRESET_PERSONALIZED_VALUE ; if it's already there, then there's nothing to do
        beq change_nothing

        lda palette_preset_lut_phones, x
        cmp setting_personal_color_index_phones
        bne perform_sync
        lda palette_preset_lut_pajamas, x
        cmp setting_personal_color_index_pajamas
        bne perform_sync
        lda palette_preset_lut_pigment, x
        cmp setting_personal_color_index_pigment
        bne perform_sync
change_nothing:
        rts
perform_sync:
        lda #PRESET_PERSONALIZED_VALUE
        sta setting_player_palette_preset
        rts
.endproc

.proc update_player_color_values
        ; Read the color index values, work out the PPU values from the global LUT,
        ; and load those colors into the player sprite for preview
        ldy setting_personal_color_index_phones
        lda player_colors_shoes_accessories_lut, y
        sta setting_personal_color_phones

        ldy setting_personal_color_index_pajamas
        lda player_colors_face_clothing_lut, y
        sta setting_personal_color_pajamas

        ldy setting_personal_color_index_pigment
        lda player_colors_face_clothing_lut, y
        sta setting_personal_color_pigment

        rts
.endproc